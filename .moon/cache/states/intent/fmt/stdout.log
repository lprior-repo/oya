Diff in /home/lewis/src/oya/crates/events/src/bus.rs:19:
 impl EventSubscription {
     /// Receive the next event.
     pub async fn recv(&mut self) -> Result<BeadEvent> {
[31m-        self.receiver
(B[m[31m-            .recv()
(B[m[31m-            .await
(B[m[31m-            .map_err(|_| Error::ChannelClosed)
(B[m[32m+        self.receiver.recv().await.map_err(|_| Error::ChannelClosed)
(B[m     }
 
     /// Try to receive an event without waiting.
Diff in /home/lewis/src/oya/crates/events/src/bus.rs:29:
     pub fn try_recv(&mut self) -> Result<BeadEvent> {
[31m-        self.receiver
(B[m[31m-            .try_recv()
(B[m[31m-            .map_err(|_| Error::ChannelClosed)
(B[m[32m+        self.receiver.try_recv().map_err(|_| Error::ChannelClosed)
(B[m     }
 }
 
Diff in /home/lewis/src/oya/crates/events/src/bus.rs:124:
     }
 
     /// Subscribe to events matching a pattern.
[31m-    pub async fn subscribe_with_pattern(&self, pattern: EventPattern) -> (String, EventSubscription) {
(B[m[32m+    pub async fn subscribe_with_pattern(
(B[m[32m+        &self,
(B[m[32m+        pattern: EventPattern,
(B[m[32m+    ) -> (String, EventSubscription) {
(B[m         let (sender, receiver) = broadcast::channel(100);
 
         let mut next_id = self.next_id.write().await;
Diff in /home/lewis/src/oya/crates/events/src/bus.rs:132:
         *next_id += 1;
 
         let mut subscribers = self.subscribers.write().await;
[31m-        subscribers.insert(
(B[m[31m-            id.clone(),
(B[m[31m-            Subscriber {
(B[m[31m-                sender,
(B[m[31m-                pattern,
(B[m[31m-            },
(B[m[31m-        );
(B[m[32m+        subscribers.insert(id.clone(), Subscriber { sender, pattern });
(B[m 
         (id, EventSubscription { receiver })
     }
Diff in /home/lewis/src/oya/crates/events/src/error.rs:9:
 #[derive(Debug, Clone)]
 pub enum Error {
     /// Event store operation failed.
[31m-    StoreFailed {
(B[m[31m-        operation: String,
(B[m[31m-        reason: String,
(B[m[31m-    },
(B[m[32m+    StoreFailed { operation: String, reason: String },
(B[m     /// Event not found.
[31m-    EventNotFound {
(B[m[31m-        event_id: String,
(B[m[31m-    },
(B[m[32m+    EventNotFound { event_id: String },
(B[m     /// Invalid event data.
[31m-    InvalidEvent {
(B[m[31m-        reason: String,
(B[m[31m-    },
(B[m[32m+    InvalidEvent { reason: String },
(B[m     /// Subscription failed.
[31m-    SubscriptionFailed {
(B[m[31m-        reason: String,
(B[m[31m-    },
(B[m[32m+    SubscriptionFailed { reason: String },
(B[m     /// Channel closed.
     ChannelClosed,
     /// Serialization error.
Diff in /home/lewis/src/oya/crates/events/src/error.rs:31:
[31m-    Serialization {
(B[m[31m-        reason: String,
(B[m[31m-    },
(B[m[32m+    Serialization { reason: String },
(B[m     /// Projection failed.
[31m-    ProjectionFailed {
(B[m[31m-        projection: String,
(B[m[31m-        reason: String,
(B[m[31m-    },
(B[m[32m+    ProjectionFailed { projection: String, reason: String },
(B[m     /// Bead not found.
[31m-    BeadNotFound {
(B[m[31m-        bead_id: String,
(B[m[31m-    },
(B[m[32m+    BeadNotFound { bead_id: String },
(B[m     /// Invalid state transition.
[31m-    InvalidTransition {
(B[m[31m-        from: String,
(B[m[31m-        to: String,
(B[m[31m-    },
(B[m[32m+    InvalidTransition { from: String, to: String },
(B[m }
 
 impl fmt::Display for Error {
Diff in /home/lewis/src/oya/crates/events/src/lib.rs:51:
 pub use bus::{EventBus, EventBusBuilder, EventPattern, EventSubscription};
 pub use error::{Error, Result};
 pub use event::BeadEvent;
[31m-pub use projection::{AllBeadsProjection, AllBeadsState, BeadProjection, ManagedProjection, Projection};
(B[m[32m+pub use projection::{
(B[m[32m+    AllBeadsProjection, AllBeadsState, BeadProjection, ManagedProjection, Projection,
(B[m[32m+};
(B[m pub use store::{EventStore, InMemoryEventStore, TracingEventStore};
 pub use types::{
     BeadId, BeadResult, BeadSpec, BeadState, Complexity, EventId, PhaseId, PhaseOutput,
Diff in /home/lewis/src/oya/crates/events/src/projection.rs:160:
                     *state.state_counts.entry(*to).or_insert(0) += 1;
                 }
             }
[31m-            BeadEvent::PhaseCompleted { bead_id, phase_id, .. } => {
(B[m[32m+            BeadEvent::PhaseCompleted {
(B[m[32m+                bead_id, phase_id, ..
(B[m[32m+            } => {
(B[m                 if let Some(bead) = state.beads.get_mut(bead_id) {
                     bead.current_phase = Some(*phase_id);
                 }
Diff in /home/lewis/src/oya/crates/events/src/projection.rs:292:
             state.beads.get(&bead_id).map(|b| b.current_state),
             Some(BeadState::Scheduled)
         );
[31m-        assert_eq!(
(B[m[31m-            state.beads.get(&bead_id).map(|b| b.history.len()),
(B[m[31m-            Some(1)
(B[m[31m-        );
(B[m[32m+        assert_eq!(state.beads.get(&bead_id).map(|b| b.history.len()), Some(1));
(B[m     }
 
     #[tokio::test]
Diff in /home/lewis/src/oya/crates/events/src/store.rs:86:
         let bead_index = self.bead_index.read().await;
 
         if let Some(indices) = bead_index.get(&bead_id) {
[31m-            Ok(indices.iter().filter_map(|&i| events.get(i).cloned()).collect())
(B[m[32m+            Ok(indices
(B[m[32m+                .iter()
(B[m[32m+                .filter_map(|&i| events.get(i).cloned())
(B[m[32m+                .collect())
(B[m         } else {
             Ok(Vec::new())
         }
Diff in /home/lewis/src/oya/crates/reconciler/src/error.rs:9:
 #[derive(Debug, Clone)]
 pub enum Error {
     /// Reconciliation failed.
[31m-    ReconcileFailed {
(B[m[31m-        reason: String,
(B[m[31m-    },
(B[m[32m+    ReconcileFailed { reason: String },
(B[m     /// Action execution failed.
[31m-    ActionFailed {
(B[m[31m-        action: String,
(B[m[31m-        reason: String,
(B[m[31m-    },
(B[m[32m+    ActionFailed { action: String, reason: String },
(B[m     /// State computation failed.
[31m-    StateFailed {
(B[m[31m-        reason: String,
(B[m[31m-    },
(B[m[32m+    StateFailed { reason: String },
(B[m     /// Bead not found.
[31m-    BeadNotFound {
(B[m[31m-        bead_id: String,
(B[m[31m-    },
(B[m[32m+    BeadNotFound { bead_id: String },
(B[m     /// Concurrency limit reached.
[31m-    ConcurrencyLimit {
(B[m[31m-        current: usize,
(B[m[31m-        max: usize,
(B[m[31m-    },
(B[m[32m+    ConcurrencyLimit { current: usize, max: usize },
(B[m     /// Event bus error.
[31m-    EventError {
(B[m[31m-        reason: String,
(B[m[31m-    },
(B[m[32m+    EventError { reason: String },
(B[m     /// Loop was stopped.
     LoopStopped,
     /// Invalid configuration.
Diff in /home/lewis/src/oya/crates/reconciler/src/error.rs:40:
[31m-    InvalidConfig {
(B[m[31m-        reason: String,
(B[m[31m-    },
(B[m[32m+    InvalidConfig { reason: String },
(B[m }
 
 impl fmt::Display for Error {
Diff in /home/lewis/src/oya/crates/reconciler/src/lib.rs:71:
 // Re-export main types
 pub use error::{Error, Result};
 pub use r#loop::{
[31m-    DesiredStateProvider, InMemoryDesiredStateProvider, LoopConfig, LoopStopper,
(B[m[31m-    ReconciliationLoop,
(B[m[32m+    DesiredStateProvider, InMemoryDesiredStateProvider, LoopConfig, LoopStopper, ReconciliationLoop,
(B[m };
[31m-pub use reconciler::{ActionExecutor, EventActionExecutor, Reconciler, ReconcilerBuilder, ReconcilerConfig};
(B[m[32m+pub use reconciler::{
(B[m[32m+    ActionExecutor, EventActionExecutor, Reconciler, ReconcilerBuilder, ReconcilerConfig,
(B[m[32m+};
(B[m pub use types::{ActualState, DesiredState, ReconcileAction, ReconcileResult};
 
Diff in /home/lewis/src/oya/crates/reconciler/src/loop.rs:260:
             interval: Duration::from_millis(10),
             ..Default::default()
         };
[31m-        let loop_runner = ReconciliationLoop::new(
(B[m[31m-            reconciler,
(B[m[31m-            desired_provider,
(B[m[31m-            projection,
(B[m[31m-            config,
(B[m[31m-        );
(B[m[32m+        let loop_runner = ReconciliationLoop::new(reconciler, desired_provider, projection, config);
(B[m 
         let result = loop_runner.reconcile_once().await;
         assert!(result.is_ok());
Diff in /home/lewis/src/oya/crates/reconciler/src/loop.rs:272:
[31m-        assert!(result.ok().unwrap_or(false), "Empty system should be converged");
(B[m[32m+        assert!(
(B[m[32m+            result.ok().unwrap_or(false),
(B[m[32m+            "Empty system should be converged"
(B[m[32m+        );
(B[m     }
 
     /// Given a desired state with one bead
Diff in /home/lewis/src/oya/crates/reconciler/src/loop.rs:292:
             .await;
 
         let config = LoopConfig::default();
[31m-        let loop_runner = ReconciliationLoop::new(
(B[m[31m-            reconciler,
(B[m[31m-            desired_provider,
(B[m[31m-            projection,
(B[m[31m-            config,
(B[m[31m-        );
(B[m[32m+        let loop_runner = ReconciliationLoop::new(reconciler, desired_provider, projection, config);
(B[m 
         let result = loop_runner.reconcile_once().await;
         assert!(result.is_ok());
Diff in /home/lewis/src/oya/crates/reconciler/src/loop.rs:304:
         // Should NOT be converged because a bead needs to be created
[31m-        assert!(!result.ok().unwrap_or(true), "System with missing bead should not be converged");
(B[m[32m+        assert!(
(B[m[32m+            !result.ok().unwrap_or(true),
(B[m[32m+            "System with missing bead should not be converged"
(B[m[32m+        );
(B[m     }
 
     /// Given a loop that is running
Diff in /home/lewis/src/oya/crates/reconciler/src/loop.rs:315:
             interval: Duration::from_millis(100),
             ..Default::default()
         };
[31m-        let mut loop_runner = ReconciliationLoop::new(
(B[m[31m-            reconciler,
(B[m[31m-            desired_provider,
(B[m[31m-            projection,
(B[m[31m-            config,
(B[m[31m-        );
(B[m[32m+        let mut loop_runner =
(B[m[32m+            ReconciliationLoop::new(reconciler, desired_provider, projection, config);
(B[m 
         let stopper = loop_runner.stopper();
 
Diff in /home/lewis/src/oya/crates/reconciler/src/loop.rs:327:
         // Start the loop in a task
[31m-        let handle = tokio::spawn(async move {
(B[m[31m-            loop_runner.run().await
(B[m[31m-        });
(B[m[32m+        let handle = tokio::spawn(async move { loop_runner.run().await });
(B[m 
         // Give it a moment to start
         tokio::time::sleep(Duration::from_millis(50)).await;
Diff in /home/lewis/src/oya/crates/reconciler/src/loop.rs:374:
         let bead_id = BeadId::new();
         provider
             .modify(|state| {
[31m-                state.add_bead(bead_id, BeadSpec::new("Test").with_complexity(Complexity::Simple));
(B[m[32m+                state.add_bead(
(B[m[32m+                    bead_id,
(B[m[32m+                    BeadSpec::new("Test").with_complexity(Complexity::Simple),
(B[m[32m+                );
(B[m             })
             .await;
 
Diff in /home/lewis/src/oya/crates/reconciler/src/loop.rs:391:
     async fn actual_state_computes_counts_correctly() {
         let (reconciler, desired_provider, projection, _) = setup();
         let config = LoopConfig::default();
[31m-        let loop_runner = ReconciliationLoop::new(
(B[m[31m-            reconciler,
(B[m[31m-            desired_provider,
(B[m[31m-            projection.clone(),
(B[m[31m-            config,
(B[m[31m-        );
(B[m[32m+        let loop_runner =
(B[m[32m+            ReconciliationLoop::new(reconciler, desired_provider, projection.clone(), config);
(B[m 
         // Manually update the projection with some beads
         use oya_events::{BeadEvent, BeadState};
Diff in /home/lewis/src/oya/crates/reconciler/src/loop.rs:403:
         let bead1 = BeadId::new();
         let bead2 = BeadId::new();
 
[31m-        projection.apply(&BeadEvent::created(
(B[m[31m-            bead1,
(B[m[31m-            BeadSpec::new("Bead 1").with_complexity(Complexity::Simple),
(B[m[31m-        )).await;
(B[m[31m-        projection.apply(&BeadEvent::state_changed(
(B[m[31m-            bead1,
(B[m[31m-            BeadState::Pending,
(B[m[31m-            BeadState::Running,
(B[m[31m-        )).await;
(B[m[32m+        projection
(B[m[32m+            .apply(&BeadEvent::created(
(B[m[32m+                bead1,
(B[m[32m+                BeadSpec::new("Bead 1").with_complexity(Complexity::Simple),
(B[m[32m+            ))
(B[m[32m+            .await;
(B[m[32m+        projection
(B[m[32m+            .apply(&BeadEvent::state_changed(
(B[m[32m+                bead1,
(B[m[32m+                BeadState::Pending,
(B[m[32m+                BeadState::Running,
(B[m[32m+            ))
(B[m[32m+            .await;
(B[m 
[31m-        projection.apply(&BeadEvent::created(
(B[m[31m-            bead2,
(B[m[31m-            BeadSpec::new("Bead 2").with_complexity(Complexity::Simple),
(B[m[31m-        )).await;
(B[m[32m+        projection
(B[m[32m+            .apply(&BeadEvent::created(
(B[m[32m+                bead2,
(B[m[32m+                BeadSpec::new("Bead 2").with_complexity(Complexity::Simple),
(B[m[32m+            ))
(B[m[32m+            .await;
(B[m 
         let proj_state = projection.state().await;
         let actual = loop_runner.build_actual_state(&proj_state);
Diff in /home/lewis/src/oya/crates/reconciler/src/reconciler.rs:130:
 
 impl Reconciler {
     /// Create a new reconciler.
[31m-    pub fn new(bus: Arc<EventBus>, executor: Arc<dyn ActionExecutor>, config: ReconcilerConfig) -> Self {
(B[m[32m+    pub fn new(
(B[m[32m+        bus: Arc<EventBus>,
(B[m[32m+        executor: Arc<dyn ActionExecutor>,
(B[m[32m+        config: ReconcilerConfig,
(B[m[32m+    ) -> Self {
(B[m         Self {
             bus,
             executor,
Diff in /home/lewis/src/oya/crates/reconciler/src/reconciler.rs:165:
         // Apply actions
         let (taken, failed) = self.apply_actions(actions).await;
 
[31m-        let result = ReconcileResult::new(
(B[m[31m-            taken,
(B[m[31m-            failed,
(B[m[31m-            desired.len(),
(B[m[31m-            actual.beads.len(),
(B[m[31m-        );
(B[m[32m+        let result = ReconcileResult::new(taken, failed, desired.len(), actual.beads.len());
(B[m 
         if result.converged {
             info!("System converged");
Diff in /home/lewis/src/oya/crates/reconciler/src/reconciler.rs:369:
         let (reconciler, _) = setup_reconciler();
         let mut desired = DesiredState::new();
         let bead_id = BeadId::new();
[31m-        desired.add_bead(bead_id, BeadSpec::new("Test").with_complexity(Complexity::Simple));
(B[m[32m+        desired.add_bead(
(B[m[32m+            bead_id,
(B[m[32m+            BeadSpec::new("Test").with_complexity(Complexity::Simple),
(B[m[32m+        );
(B[m 
         let actual = ActualState::new();
 
Diff in /home/lewis/src/oya/crates/reconciler/src/reconciler.rs:378:
         let result = result.ok();
 
         // Should have a CreateBead action
[31m-        let has_create = result.as_ref()
(B[m[31m-            .map(|r| r.actions_taken.iter().any(|a| matches!(a, ReconcileAction::CreateBead { .. })))
(B[m[32m+        let has_create = result
(B[m[32m+            .as_ref()
(B[m[32m+            .map(|r| {
(B[m[32m+                r.actions_taken
(B[m[32m+                    .iter()
(B[m[32m+                    .any(|a| matches!(a, ReconcileAction::CreateBead { .. }))
(B[m[32m+            })
(B[m             .unwrap_or(false);
         assert!(has_create);
     }
Diff in /home/lewis/src/oya/crates/reconciler/src/reconciler.rs:389:
         let (reconciler, _) = setup_reconciler();
         let mut desired = DesiredState::new();
         let bead_id = BeadId::new();
[31m-        desired.add_bead(bead_id, BeadSpec::new("Test").with_complexity(Complexity::Simple));
(B[m[32m+        desired.add_bead(
(B[m[32m+            bead_id,
(B[m[32m+            BeadSpec::new("Test").with_complexity(Complexity::Simple),
(B[m[32m+        );
(B[m 
         let actual = ActualState::new();
         let actions = reconciler.diff(&desired, &actual);
Diff in /home/lewis/src/oya/crates/reconciler/src/reconciler.rs:396:
 
         assert!(!actions.is_empty());
[31m-        assert!(actions.iter().any(|a| matches!(a, ReconcileAction::CreateBead { .. })));
(B[m[32m+        assert!(actions
(B[m[32m+            .iter()
(B[m[32m+            .any(|a| matches!(a, ReconcileAction::CreateBead { .. })));
(B[m     }
 
     #[tokio::test]
Diff in /home/lewis/src/oya/crates/reconciler/src/reconciler.rs:425:
         let actions = reconciler.diff(&desired, &actual);
 
         // Should not have any StartBead actions
[31m-        let has_start = actions.iter().any(|a| matches!(a, ReconcileAction::StartBead { .. }));
(B[m[32m+        let has_start = actions
(B[m[32m+            .iter()
(B[m[32m+            .any(|a| matches!(a, ReconcileAction::StartBead { .. }));
(B[m         assert!(!has_start);
     }
 
Diff in /home/lewis/src/oya/crates/reconciler/src/reconciler.rs:442:
 
         assert!(result.is_ok());
         let reconciler = result.ok();
[31m-        assert_eq!(reconciler.as_ref().map(|r| r.config.max_concurrent), Some(5));
(B[m[32m+        assert_eq!(
(B[m[32m+            reconciler.as_ref().map(|r| r.config.max_concurrent),
(B[m[32m+            Some(5)
(B[m[32m+        );
(B[m         assert_eq!(reconciler.map(|r| r.config.auto_start), Some(false));
     }
 }
Diff in /home/lewis/src/oya/crates/reconciler/src/types.rs:136:
 #[derive(Debug, Clone, Serialize, Deserialize)]
 pub enum ReconcileAction {
     /// Create a new bead.
[31m-    CreateBead {
(B[m[31m-        bead_id: BeadId,
(B[m[31m-        spec: BeadSpec,
(B[m[31m-    },
(B[m[32m+    CreateBead { bead_id: BeadId, spec: BeadSpec },
(B[m     /// Start a bead (transition to Running).
[31m-    StartBead {
(B[m[31m-        bead_id: BeadId,
(B[m[31m-    },
(B[m[32m+    StartBead { bead_id: BeadId },
(B[m     /// Stop a bead.
[31m-    StopBead {
(B[m[31m-        bead_id: BeadId,
(B[m[31m-        reason: String,
(B[m[31m-    },
(B[m[32m+    StopBead { bead_id: BeadId, reason: String },
(B[m     /// Retry a failed bead.
[31m-    RetryBead {
(B[m[31m-        bead_id: BeadId,
(B[m[31m-    },
(B[m[32m+    RetryBead { bead_id: BeadId },
(B[m     /// Mark a bead as complete.
[31m-    MarkComplete {
(B[m[31m-        bead_id: BeadId,
(B[m[31m-        result: BeadResult,
(B[m[31m-    },
(B[m[32m+    MarkComplete { bead_id: BeadId, result: BeadResult },
(B[m     /// Update bead dependencies.
     UpdateDependencies {
         bead_id: BeadId,
Diff in /home/lewis/src/oya/crates/reconciler/src/types.rs:164:
         dependencies: Vec<BeadId>,
     },
     /// Schedule a bead (transition to Scheduled).
[31m-    ScheduleBead {
(B[m[31m-        bead_id: BeadId,
(B[m[31m-    },
(B[m[32m+    ScheduleBead { bead_id: BeadId },
(B[m     /// Delete a bead.
[31m-    DeleteBead {
(B[m[31m-        bead_id: BeadId,
(B[m[31m-    },
(B[m[32m+    DeleteBead { bead_id: BeadId },
(B[m }
 
 impl ReconcileAction {
Diff in /home/lewis/src/oya/crates/workflow/src/engine.rs:113:
                 .await?;
 
             // Execute with retries
[31m-            let result = self.execute_phase_with_retries(&workflow, &phase, last_output.clone()).await;
(B[m[32m+            let result = self
(B[m[32m+                .execute_phase_with_retries(&workflow, &phase, last_output.clone())
(B[m[32m+                .await;
(B[m 
             match result {
                 Ok(output) => {
Diff in /home/lewis/src/oya/crates/workflow/src/engine.rs:128:
                     self.storage
                         .append_journal(
                             workflow.id,
[31m-                            JournalEntry::phase_completed(phase.id, &phase.name, output.data.clone()),
(B[m[32m+                            JournalEntry::phase_completed(
(B[m[32m+                                phase.id,
(B[m[32m+                                &phase.name,
(B[m[32m+                                output.data.clone(),
(B[m[32m+                            ),
(B[m                         )
                         .await?;
 
Diff in /home/lewis/src/oya/crates/workflow/src/engine.rs:170:
                     self.transition_state(&mut workflow, WorkflowState::Failed)
                         .await?;
 
[31m-                    return Ok(WorkflowResult::failure(workflow.id, phase_outputs, e.to_string()));
(B[m[32m+                    return Ok(WorkflowResult::failure(
(B[m[32m+                        workflow.id,
(B[m[32m+                        phase_outputs,
(B[m[32m+                        e.to_string(),
(B[m[32m+                    ));
(B[m                 }
             }
         }
Diff in /home/lewis/src/oya/crates/workflow/src/engine.rs:248:
                     }
 
                     // Exponential backoff
[31m-                    let backoff = std::time::Duration::from_millis(
(B[m[31m-                        100 * 2u64.saturating_pow(attempt - 1),
(B[m[31m-                    );
(B[m[32m+                    let backoff =
(B[m[32m+                        std::time::Duration::from_millis(100 * 2u64.saturating_pow(attempt - 1));
(B[m                     tokio::time::sleep(backoff).await;
 
                     attempt += 1;
Diff in /home/lewis/src/oya/crates/workflow/src/engine.rs:279:
         phase: &crate::types::Phase,
         output: &PhaseOutput,
     ) -> Result<()> {
[31m-        let checkpoint = Checkpoint::new(phase.id, Vec::new(), Vec::new())
(B[m[31m-            .with_outputs(output.data.clone());
(B[m[32m+        let checkpoint =
(B[m[32m+            Checkpoint::new(phase.id, Vec::new(), Vec::new()).with_outputs(output.data.clone());
(B[m 
         self.storage
             .save_checkpoint(workflow.id, &checkpoint)
Diff in /home/lewis/src/oya/crates/workflow/src/engine.rs:401:
                 phase_id, output, ..
             } = entry
             {
[31m-                phase_outputs.push((
(B[m[31m-                    *phase_id,
(B[m[31m-                    PhaseOutput::success(output.clone()),
(B[m[31m-                ));
(B[m[32m+                phase_outputs.push((*phase_id, PhaseOutput::success(output.clone())));
(B[m             }
         }
 
Diff in /home/lewis/src/oya/crates/workflow/src/engine.rs:451:
     }
 
     /// Transition workflow state.
[31m-    async fn transition_state(
(B[m[31m-        &self,
(B[m[31m-        workflow: &mut Workflow,
(B[m[31m-        to: WorkflowState,
(B[m[31m-    ) -> Result<()> {
(B[m[32m+    async fn transition_state(&self, workflow: &mut Workflow, to: WorkflowState) -> Result<()> {
(B[m         let from = workflow.state;
 
         if !from.can_transition_to(to) {
Diff in /home/lewis/src/oya/crates/workflow/src/engine.rs:500:
         registry.register("test", Arc::new(NoOpHandler::new("test")));
         registry.register("deploy", Arc::new(NoOpHandler::new("deploy")));
 
[31m-        let engine = WorkflowEngine::new(
(B[m[31m-            storage.clone(),
(B[m[31m-            Arc::new(registry),
(B[m[31m-            EngineConfig::default(),
(B[m[31m-        );
(B[m[32m+        let engine =
(B[m[32m+            WorkflowEngine::new(storage.clone(), Arc::new(registry), EngineConfig::default());
(B[m 
         (engine, storage)
     }
Diff in /home/lewis/src/oya/crates/workflow/src/engine.rs:517:
         let result = engine.run(workflow).await;
         assert!(result.is_ok());
         let result = result.ok();
[31m-        assert!(result.as_ref().map(|r| r.state == WorkflowState::Completed).unwrap_or(false));
(B[m[32m+        assert!(result
(B[m[32m+            .as_ref()
(B[m[32m+            .map(|r| r.state == WorkflowState::Completed)
(B[m[32m+            .unwrap_or(false));
(B[m     }
 
     #[tokio::test]
Diff in /home/lewis/src/oya/crates/workflow/src/engine.rs:529:
         let result = engine.run(workflow).await;
         assert!(result.is_ok());
         let result = result.ok();
[31m-        assert!(result.as_ref().map(|r| r.state == WorkflowState::Completed).unwrap_or(false));
(B[m[32m+        assert!(result
(B[m[32m+            .as_ref()
(B[m[32m+            .map(|r| r.state == WorkflowState::Completed)
(B[m[32m+            .unwrap_or(false));
(B[m         assert_eq!(result.map(|r| r.phase_outputs.len()).unwrap_or(0), 1);
     }
 
Diff in /home/lewis/src/oya/crates/workflow/src/engine.rs:544:
         let result = engine.run(workflow).await;
         assert!(result.is_ok());
         let result = result.ok();
[31m-        assert!(result.as_ref().map(|r| r.state == WorkflowState::Completed).unwrap_or(false));
(B[m[32m+        assert!(result
(B[m[32m+            .as_ref()
(B[m[32m+            .map(|r| r.state == WorkflowState::Completed)
(B[m[32m+            .unwrap_or(false));
(B[m         assert_eq!(result.map(|r| r.phase_outputs.len()).unwrap_or(0), 3);
     }
 
Diff in /home/lewis/src/oya/crates/workflow/src/engine.rs:551:
     #[tokio::test]
     async fn test_missing_handler() {
         let (engine, _) = setup_engine();
[31m-        let workflow = Workflow::new("unknown")
(B[m[31m-            .add_phase(Phase::new("unknown_phase"));
(B[m[32m+        let workflow = Workflow::new("unknown").add_phase(Phase::new("unknown_phase"));
(B[m 
         let result = engine.run(workflow).await;
         assert!(result.is_err());
Diff in /home/lewis/src/oya/crates/workflow/src/engine.rs:561:
     #[tokio::test]
     async fn test_workflow_persisted() {
         let (engine, storage) = setup_engine();
[31m-        let workflow = Workflow::new("persist")
(B[m[31m-            .add_phase(Phase::new("build"));
(B[m[32m+        let workflow = Workflow::new("persist").add_phase(Phase::new("build"));
(B[m 
         let workflow_id = workflow.id;
         let _ = engine.run(workflow).await;
Diff in /home/lewis/src/oya/crates/workflow/src/engine.rs:590:
     #[tokio::test]
     async fn test_journal_recorded() {
         let (engine, storage) = setup_engine();
[31m-        let workflow = Workflow::new("journal")
(B[m[31m-            .add_phase(Phase::new("build"));
(B[m[32m+        let workflow = Workflow::new("journal").add_phase(Phase::new("build"));
(B[m 
         let workflow_id = workflow.id;
         let _ = engine.run(workflow).await;
Diff in /home/lewis/src/oya/crates/workflow/src/error.rs:9:
 #[derive(Debug, Clone)]
 pub enum Error {
     /// Phase execution failed.
[31m-    PhaseFailed {
(B[m[31m-        phase_name: String,
(B[m[31m-        reason: String,
(B[m[31m-    },
(B[m[32m+    PhaseFailed { phase_name: String, reason: String },
(B[m     /// Phase timeout exceeded.
     PhaseTimeout {
         phase_name: String,
Diff in /home/lewis/src/oya/crates/workflow/src/error.rs:19:
         timeout_secs: u64,
     },
     /// Rollback failed.
[31m-    RollbackFailed {
(B[m[31m-        phase_name: String,
(B[m[31m-        reason: String,
(B[m[31m-    },
(B[m[32m+    RollbackFailed { phase_name: String, reason: String },
(B[m     /// Checkpoint creation failed.
[31m-    CheckpointFailed {
(B[m[31m-        reason: String,
(B[m[31m-    },
(B[m[32m+    CheckpointFailed { reason: String },
(B[m     /// Checkpoint not found.
[31m-    CheckpointNotFound {
(B[m[31m-        phase_id: String,
(B[m[31m-    },
(B[m[32m+    CheckpointNotFound { phase_id: String },
(B[m     /// Rewind failed.
[31m-    RewindFailed {
(B[m[31m-        reason: String,
(B[m[31m-    },
(B[m[32m+    RewindFailed { reason: String },
(B[m     /// Journal replay failed.
[31m-    ReplayFailed {
(B[m[31m-        reason: String,
(B[m[31m-    },
(B[m[32m+    ReplayFailed { reason: String },
(B[m     /// Invalid state transition.
[31m-    InvalidTransition {
(B[m[31m-        from: String,
(B[m[31m-        to: String,
(B[m[31m-    },
(B[m[32m+    InvalidTransition { from: String, to: String },
(B[m     /// Storage operation failed.
[31m-    StorageFailed {
(B[m[31m-        operation: String,
(B[m[31m-        reason: String,
(B[m[31m-    },
(B[m[32m+    StorageFailed { operation: String, reason: String },
(B[m     /// Workflow not found.
[31m-    WorkflowNotFound {
(B[m[31m-        workflow_id: String,
(B[m[31m-    },
(B[m[32m+    WorkflowNotFound { workflow_id: String },
(B[m     /// Phase not found.
[31m-    PhaseNotFound {
(B[m[31m-        phase_name: String,
(B[m[31m-    },
(B[m[32m+    PhaseNotFound { phase_name: String },
(B[m     /// Serialization error.
[31m-    Serialization {
(B[m[31m-        reason: String,
(B[m[31m-    },
(B[m[32m+    Serialization { reason: String },
(B[m     /// Handler not registered.
[31m-    HandlerNotFound {
(B[m[31m-        phase_name: String,
(B[m[31m-    },
(B[m[32m+    HandlerNotFound { phase_name: String },
(B[m     /// Maximum retries exceeded.
[31m-    MaxRetriesExceeded {
(B[m[31m-        phase_name: String,
(B[m[31m-        attempts: u32,
(B[m[31m-    },
(B[m[32m+    MaxRetriesExceeded { phase_name: String, attempts: u32 },
(B[m }
 
 impl fmt::Display for Error {
Diff in /home/lewis/src/oya/crates/workflow/src/error.rs:241:
     pub fn is_retryable(&self) -> bool {
         matches!(
             self,
[31m-            Self::PhaseFailed { .. }
(B[m[31m-                | Self::PhaseTimeout { .. }
(B[m[31m-                | Self::StorageFailed { .. }
(B[m[32m+            Self::PhaseFailed { .. } | Self::PhaseTimeout { .. } | Self::StorageFailed { .. }
(B[m         )
     }
 }
Diff in /home/lewis/src/oya/crates/workflow/src/handler.rs:310:
 
     #[tokio::test]
     async fn test_fn_handler() {
[31m-        let handler = FnHandler::new("double", |_ctx| {
(B[m[31m-            Ok(PhaseOutput::success(vec![2, 4, 6]))
(B[m[31m-        });
(B[m[32m+        let handler = FnHandler::new("double", |_ctx| Ok(PhaseOutput::success(vec![2, 4, 6])));
(B[m         let ctx = make_context();
         let result = handler.execute(&ctx).await;
         assert!(result.is_ok());
Diff in /home/lewis/src/oya/crates/workflow/src/storage.rs:21:
     async fn list_workflows(&self) -> Result<Vec<Workflow>>;
 
     /// Save a checkpoint.
[31m-    async fn save_checkpoint(&self, workflow_id: WorkflowId, checkpoint: &Checkpoint) -> Result<()>;
(B[m[32m+    async fn save_checkpoint(&self, workflow_id: WorkflowId, checkpoint: &Checkpoint)
(B[m[32m+        -> Result<()>;
(B[m 
     /// Load checkpoints for a workflow.
     async fn load_checkpoints(&self, workflow_id: WorkflowId) -> Result<Vec<Checkpoint>>;
Diff in /home/lewis/src/oya/crates/workflow/src/storage.rs:51:
 #[derive(Default)]
 pub struct InMemoryStorage {
     workflows: tokio::sync::RwLock<std::collections::HashMap<WorkflowId, Workflow>>,
[31m-    checkpoints:
(B[m[31m-        tokio::sync::RwLock<std::collections::HashMap<WorkflowId, Vec<Checkpoint>>>,
(B[m[32m+    checkpoints: tokio::sync::RwLock<std::collections::HashMap<WorkflowId, Vec<Checkpoint>>>,
(B[m     journals: tokio::sync::RwLock<std::collections::HashMap<WorkflowId, Journal>>,
 }
 
Diff in /home/lewis/src/oya/crates/workflow/src/storage.rs:88:
         Ok(self.workflows.read().await.values().cloned().collect())
     }
 
[31m-    async fn save_checkpoint(&self, workflow_id: WorkflowId, checkpoint: &Checkpoint) -> Result<()> {
(B[m[32m+    async fn save_checkpoint(
(B[m[32m+        &self,
(B[m[32m+        workflow_id: WorkflowId,
(B[m[32m+        checkpoint: &Checkpoint,
(B[m[32m+    ) -> Result<()> {
(B[m         self.checkpoints
             .write()
             .await
Diff in /home/lewis/src/oya/crates/workflow/src/types.rs:683:
         let phase_id = PhaseId::new();
 
         journal.append(JournalEntry::phase_started(phase_id, "build"));
[31m-        journal.append(JournalEntry::phase_completed(phase_id, "build", vec![1, 2, 3]));
(B[m[32m+        journal.append(JournalEntry::phase_completed(
(B[m[32m+            phase_id,
(B[m[32m+            "build",
(B[m[32m+            vec![1, 2, 3],
(B[m[32m+        ));
(B[m 
         assert_eq!(journal.len(), 2);
         assert_eq!(journal.entries_for_phase(phase_id).len(), 2);
Diff in /home/lewis/src/oya/crates/factory/src/codegen.rs:8:
 //! - Explicitly handles all errors
 
 use crate::error::{Error, Result};
[31m-use crate::functional::{generate_functional_module, FunctionStub, Parameter};
(B[m[32m+use crate::functional::{FunctionStub, Parameter, generate_functional_module};
(B[m 
 /// Bead requirement specification.
 #[derive(Debug, Clone, serde::Deserialize)]
Diff in /home/lewis/src/oya/crates/factory/src/error.rs:35:
     #[error("not in a git repository")]
     NotInRepo,
 
[31m-    #[error("could not detect language from repository files (looked for gleam.toml, go.mod, Cargo.toml, pyproject.toml, package.json)")]
(B[m[32m+    #[error(
(B[m[32m+        "could not detect language from repository files (looked for gleam.toml, go.mod, Cargo.toml, pyproject.toml, package.json)"
(B[m[32m+    )]
(B[m     LanguageDetectionFailed,
 
     #[error("could not determine base branch")]
Diff in /home/lewis/src/oya/crates/factory/src/lib.rs:42:
 
 // Re-export commonly used items
 pub use codegen::{
[31m-    generate_from_bead, parse_bead_spec, simple_function_spec, spec_to_prompt,
(B[m[31m-    validate_functional_code, BeadSpec, FunctionRequirement,
(B[m[32m+    BeadSpec, FunctionRequirement, generate_from_bead, parse_bead_spec, simple_function_spec,
(B[m[32m+    spec_to_prompt, validate_functional_code,
(B[m };
 pub use error::{Error, Result};
 pub use functional::{
Diff in /home/lewis/src/oya/crates/factory/src/lib.rs:50:
[31m-    audit_functional_style, format_violations_report, generate_functional_module,
(B[m[31m-    has_critical_violations, ForbiddenPattern, FunctionalAudit,
(B[m[32m+    ForbiddenPattern, FunctionalAudit, audit_functional_style, format_violations_report,
(B[m[32m+    generate_functional_module, has_critical_violations,
(B[m };
[31m-pub use quality_gates::{enforce_functional_quality, FunctionalGate, QualityGateResult};
(B[m[32m+pub use quality_gates::{FunctionalGate, QualityGateResult, enforce_functional_quality};
(B[m 
Diff in /home/lewis/src/oya/crates/factory/src/pipeline.rs:10:
 
 use crate::domain::{Language, Stage, Task};
 use crate::error::{Error, Result};
[31m-use crate::retry::{retry_on_retryable, RetryConfig};
(B[m[32m+use crate::retry::{RetryConfig, retry_on_retryable};
(B[m use crate::stages::execute_stage;
 
 /// Result of executing a single stage.
Diff in /home/lewis/src/oya/crates/factory/src/quality_gates.rs:7:
 use tracing::{debug, warn};
 
 use crate::error::{Error, Result};
[31m-use crate::functional::{audit_functional_style, FunctionalAudit, ViolationSeverity};
(B[m[32m+use crate::functional::{FunctionalAudit, ViolationSeverity, audit_functional_style};
(B[m 
 /// Minimum functional code compliance percentage required (95%).
 const MIN_FUNCTIONAL_COMPLIANCE: f64 = 95.0;
Diff in /home/lewis/src/oya/crates/intent/src/config.rs:79:
             "TRACE" => Ok(Self::Trace),
             _ => Err(IntentError::validation(
                 "log_level",
[31m-                format!(
(B[m[31m-                    "Invalid log level: '{s}'. Must be ERROR, WARN, INFO, DEBUG, or TRACE"
(B[m[31m-                ),
(B[m[32m+                format!("Invalid log level: '{s}'. Must be ERROR, WARN, INFO, DEBUG, or TRACE"),
(B[m             )),
         }
     }
Diff in /home/lewis/src/oya/crates/intent/src/config.rs:265:
 fn get_xdg_config_path() -> IntentResult<PathBuf> {
     ProjectDirs::from("", "", "intent")
         .map(|dirs| dirs.config_dir().join("config.toml"))
[31m-        .ok_or_else(|| {
(B[m[31m-            IntentError::config("Unable to determine XDG config directory for platform")
(B[m[31m-        })
(B[m[32m+        .ok_or_else(|| IntentError::config("Unable to determine XDG config directory for platform"))
(B[m }
 
 /// Fallback to local directory config path.
Diff in /home/lewis/src/oya/crates/intent/src/types.rs:69:
         {
             return Err(IntentError::validation(
                 "spec_name",
[31m-                format!("Spec name contains invalid characters: '{name}'. Only alphanumeric, hyphens, underscores, dots, and slashes allowed"),
(B[m[32m+                format!(
(B[m[32m+                    "Spec name contains invalid characters: '{name}'. Only alphanumeric, hyphens, underscores, dots, and slashes allowed"
(B[m[32m+                ),
(B[m             ));
         }
 
Diff in /home/lewis/src/oya/crates/intent/src/types.rs:152:
     /// ```
     pub fn try_new(url: impl AsRef<str>) -> Result<Self, IntentError> {
         let url_str = url.as_ref();
[31m-        url::Url::parse(url_str).map(Self).map_err(|e| {
(B[m[31m-            IntentError::validation("url", format!("Invalid URL '{url_str}': {e}"))
(B[m[31m-        })
(B[m[32m+        url::Url::parse(url_str)
(B[m[32m+            .map(Self)
(B[m[32m+            .map_err(|e| IntentError::validation("url", format!("Invalid URL '{url_str}': {e}")))
(B[m     }
 
     /// Get the URL as a string slice
Diff in /home/lewis/src/oya/crates/intent/src/types.rs:282:
             "OPTIONS" => Ok(Self::Options),
             _ => Err(IntentError::validation(
                 "http_method",
[31m-                format!("Invalid HTTP method: '{s}'. Must be GET, POST, PUT, PATCH, DELETE, HEAD, or OPTIONS"),
(B[m[32m+                format!(
(B[m[32m+                    "Invalid HTTP method: '{s}'. Must be GET, POST, PUT, PATCH, DELETE, HEAD, or OPTIONS"
(B[m[32m+                ),
(B[m             )),
         }
     }
Diff in /home/lewis/src/oya/crates/intent/src/types.rs:344:
         }
 
         // Validate characters: alphanumeric and hyphens only
[31m-        if !name
(B[m[31m-            .chars()
(B[m[31m-            .all(|c| c.is_ascii_alphanumeric() || c == '-')
(B[m[31m-        {
(B[m[32m+        if !name.chars().all(|c| c.is_ascii_alphanumeric() || c == '-') {
(B[m             return Err(IntentError::validation(
                 "header_name",
[31m-                format!("Header name contains invalid characters: '{name}'. Only ASCII alphanumeric and hyphens allowed"),
(B[m[32m+                format!(
(B[m[32m+                    "Header name contains invalid characters: '{name}'. Only ASCII alphanumeric and hyphens allowed"
(B[m[32m+                ),
(B[m             ));
         }
 
Diff in /home/lewis/src/oya/crates/intent/src/types.rs:438:
         }) {
             return Err(IntentError::validation(
                 "header_value",
[31m-                format!("Header value contains invalid characters: '{value}'. Only ASCII printable characters and whitespace allowed"),
(B[m[32m+                format!(
(B[m[32m+                    "Header value contains invalid characters: '{value}'. Only ASCII printable characters and whitespace allowed"
(B[m[32m+                ),
(B[m             ));
         }
 
Diff in /home/lewis/src/oya/crates/intent/src/types.rs:1446:
         assert!(StatusCode::try_new(500).unwrap().is_server_error());
         assert!(StatusCode::try_new(599).unwrap().is_server_error());
         assert!(!StatusCode::try_new(499).unwrap().is_server_error());
[31m-        assert!(!StatusCode::try_new(600).unwrap_or(StatusCode::ok()).is_server_error());
(B[m[32m+        assert!(
(B[m[32m+            !StatusCode::try_new(600)
(B[m[32m+                .unwrap_or(StatusCode::ok())
(B[m[32m+                .is_server_error()
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /home/lewis/src/oya/crates/opencode/src/client.rs:89:
         // Spawn a task to run the CLI and send chunks
         tokio::spawn(async move {
             if let Err(e) = stream_cli_output(&config, &prompt, tx.clone()).await {
[31m-                let _ = tx
(B[m[31m-                    .send(Err(Error::stream_error(e.to_string())))
(B[m[31m-                    .await;
(B[m[32m+                let _ = tx.send(Err(Error::stream_error(e.to_string()))).await;
(B[m             }
         });
 
Diff in /home/lewis/src/oya/crates/opencode/src/client.rs:216:
     prompt: &str,
     tx: mpsc::Sender<Result<StreamChunk>>,
 ) -> Result<()> {
[31m-    let mut args = vec![
(B[m[31m-        "-p".to_string(),
(B[m[31m-        prompt.to_string(),
(B[m[31m-        "-q".to_string(),
(B[m[31m-    ];
(B[m[32m+    let mut args = vec!["-p".to_string(), prompt.to_string(), "-q".to_string()];
(B[m 
     if let Some(ref cwd) = config.working_directory {
         args.push("-c".to_string());
Diff in /home/lewis/src/oya/crates/opencode/src/client.rs:261:
     let final_chunk = if status.success() {
         StreamChunk::final_chunk("", sequence + 1)
     } else {
[31m-        StreamChunk::error(format!("Process exited with status: {status}"), sequence + 1)
(B[m[32m+        StreamChunk::error(
(B[m[32m+            format!("Process exited with status: {status}"),
(B[m[32m+            sequence + 1,
(B[m[32m+        )
(B[m     };
 
     let _ = tx.send(Ok(final_chunk)).await;
Diff in /home/lewis/src/oya/crates/opencode/src/client.rs:316:
         assert!(result.is_ok());
         let result = result.ok();
         assert!(result.as_ref().map(|r| r.success).unwrap_or(false));
[31m-        assert_eq!(result.map(|r| r.output), Some("This is plain text output".to_string()));
(B[m[32m+        assert_eq!(
(B[m[32m+            result.map(|r| r.output),
(B[m[32m+            Some("This is plain text output".to_string())
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /home/lewis/src/oya/crates/opencode/src/executor.rs:408:
         let prompt = ctx.generate_prompt();
         assert!(prompt.is_ok());
         let prompt = prompt.ok();
[31m-        assert!(prompt.as_ref().map(|p| p.contains("implement")).unwrap_or(false));
(B[m[31m-        assert!(prompt.as_ref().map(|p| p.contains("No unsafe code")).unwrap_or(false));
(B[m[32m+        assert!(
(B[m[32m+            prompt
(B[m[32m+                .as_ref()
(B[m[32m+                .map(|p| p.contains("implement"))
(B[m[32m+                .unwrap_or(false)
(B[m[32m+        );
(B[m[32m+        assert!(
(B[m[32m+            prompt
(B[m[32m+                .as_ref()
(B[m[32m+                .map(|p| p.contains("No unsafe code"))
(B[m[32m+                .unwrap_or(false)
(B[m[32m+        );
(B[m     }
 
     #[test]
Diff in /home/lewis/src/oya/crates/opencode/src/lib.rs:46:
 pub use client::OpencodeClient;
 pub use config::{AgentMode, OpencodeConfig};
 pub use error::{Error, Result};
[31m-pub use executor::{AIExecutor, PhaseContext, PhaseHandler, PhaseInput, PhaseOutput, PhaseRegistry};
(B[m[32m+pub use executor::{
(B[m[32m+    AIExecutor, PhaseContext, PhaseHandler, PhaseInput, PhaseOutput, PhaseRegistry,
(B[m[32m+};
(B[m pub use types::{
     ChunkType, CommandExecution, ExecutionResult, ModificationType, ModifiedFile, StreamChunk,
     TokenUsage,
Diff in /home/lewis/src/oya/src/main.rs:8:
 
 use clap::Parser;
 use oya_factory::{
[31m-    audit,
(B[m[31m-    domain::{filter_stages, get_stage, Slug, Task, TaskStatus},
(B[m[32m+    Result, audit,
(B[m[32m+    domain::{Slug, Task, TaskStatus, filter_stages, get_stage},
(B[m     persistence::{list_all_tasks, load_task_record, save_task_record},
     repo::{detect_language, detect_repo_root},
     stages::{execute_stage, execute_stages_dry_run},
Diff in /home/lewis/src/oya/src/main.rs:16:
     worktree::create_worktree,
[31m-    Result,
(B[m };
 
 use crate::cli::{Cli, Commands, HELP_TEXT};
