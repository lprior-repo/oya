//! Initialize ZJJ - sets up everything needed

use std::{
    fmt::Write,
    fs,
    path::{Path, PathBuf},
};

use anyhow::{bail, Context, Result};

use crate::{
    cli::{is_jj_installed, is_zellij_installed},
    db::SessionDb,
};

/// Default configuration content from config.cue
const DEFAULT_CONFIG: &str = r#"# jjz Configuration File
# This file was generated by 'jjz init'

workspace_dir = "../{repo}__workspaces"
main_branch = ""  # auto-detect
default_template = "standard"
state_db = ".jjz/state.db"

[watch]
enabled = true
debounce_ms = 100
paths = [".beads/beads.db"]

[hooks]
post_create = []
pre_remove = []
post_merge = []

[zellij]
session_prefix = "jjz"
use_tabs = true
layout_dir = ".jjz/layouts"

[zellij.panes.main]
command = "claude"
args = []
size = "70%"

[zellij.panes.beads]
command = "bv"
args = []
size = "50%"

[zellij.panes.status]
command = "jjz"
args = ["status", "--watch"]
size = "50%"

[zellij.panes.float]
enabled = true
command = ""
width = "80%"
height = "60%"

[dashboard]
refresh_ms = 1000
theme = "default"
columns = ["name", "status", "branch", "changes", "beads"]
vim_keys = true

[agent]
command = "claude"

[agent.env]

[session]
auto_commit = false
commit_prefix = "wip:"
"#;

/// Run the init command
///
/// This command:
/// 1. Checks that required dependencies (jj, zellij) are installed
/// 2. Initializes a JJ repository if not already present
/// 3. Creates the .jjz directory structure:
///    - .jjz/config.toml (default configuration)
///    - .jjz/state.db (sessions database)
///    - .jjz/layouts/ (Zellij layouts directory)
pub fn run() -> Result<()> {
    run_with_cwd(None)
}

/// Run the init command with an optional working directory
///
/// If `cwd` is Some, operations will be performed relative to that directory.
/// If `cwd` is None, operations will use the current working directory.
pub fn run_with_cwd(cwd: Option<&Path>) -> Result<()> {
    let cwd = match cwd {
        Some(p) => PathBuf::from(p),
        None => std::env::current_dir().context("Failed to get current directory")?,
    };

    // Check required dependencies
    check_dependencies()?;

    // Initialize JJ repo if needed
    ensure_jj_repo_with_cwd(&cwd)?;

    // Get the repo root using the provided cwd
    let root = jj_root_with_cwd(&cwd)?;
    let zjj_dir = root.join(".jjz");

    // Check if already initialized
    if zjj_dir.exists() {
        println!("ZJZ already initialized in this repository.");
        return Ok(());
    }

    // Create .jjz directory
    fs::create_dir_all(&zjj_dir).context("Failed to create .jjz directory")?;

    // Create config.toml with defaults
    let config_path = zjj_dir.join("config.toml");
    fs::write(&config_path, DEFAULT_CONFIG).context("Failed to create config.toml")?;

    // Create layouts directory
    let layouts_dir = zjj_dir.join("layouts");
    fs::create_dir_all(&layouts_dir).context("Failed to create layouts directory")?;

    // Initialize the database
    let db_path = zjj_dir.join("state.db");
    let _db = SessionDb::open(&db_path)?;

    println!("Initialized ZJZ in {}", root.display());
    println!("  Data directory: .jjz/");
    println!("  Configuration: .jjz/config.toml");
    println!("  State database: .jjz/state.db");
    println!("  Layouts: .jjz/layouts/");

    Ok(())
}

/// Get the JJ root using a specific working directory
fn jj_root_with_cwd(cwd: &Path) -> Result<PathBuf> {
    let output = std::process::Command::new("jj")
        .args(["root"])
        .current_dir(cwd)
        .output()
        .context("Failed to run jj root")?;

    if !output.status.success() {
        bail!("jj failed: {}", String::from_utf8_lossy(&output.stderr));
    }

    let root = String::from_utf8_lossy(&output.stdout).trim().to_string();
    Ok(PathBuf::from(root))
}

/// Check that required dependencies are installed
fn check_dependencies() -> Result<()> {
    let mut missing = Vec::new();

    if !is_jj_installed() {
        missing.push("jj (Jujutsu)");
    }

    if !is_zellij_installed() {
        missing.push("zellij");
    }

    if missing.is_empty() {
        return Ok(());
    }

    let mut msg = String::from("Missing required dependencies:\n\n");

    for dep in &missing {
        let _ = writeln!(msg, "  - {dep}");
    }

    msg.push_str("\nInstallation instructions:\n");

    if missing.contains(&"jj (Jujutsu)") {
        msg.push_str("\n  jj (Jujutsu):\n");
        msg.push_str("    cargo install jj-cli\n");
        msg.push_str("    # or: brew install jj\n");
        msg.push_str("    # or: https://martinvonz.github.io/jj/latest/install-and-setup/\n");
    }

    if missing.contains(&"zellij") {
        msg.push_str("\n  zellij:\n");
        msg.push_str("    cargo install zellij\n");
        msg.push_str("    # or: brew install zellij\n");
        msg.push_str("    # or: https://zellij.dev/documentation/installation\n");
    }

    bail!("{msg}")
}

/// Ensure we're in a JJ repository, initializing one if needed with a specific cwd
fn ensure_jj_repo_with_cwd(cwd: &Path) -> Result<()> {
    if is_jj_repo_with_cwd(cwd)? {
        return Ok(());
    }

    println!("No JJ repository found. Initializing one...");
    init_jj_repo_with_cwd(cwd)?;
    println!("Initialized JJ repository.");

    Ok(())
}

/// Check if we're in a JJ repo using a specific cwd
fn is_jj_repo_with_cwd(cwd: &Path) -> Result<bool> {
    let output = std::process::Command::new("jj")
        .args(["status"])
        .current_dir(cwd)
        .output()?;

    Ok(output.status.success())
}

/// Initialize a JJ repo using a specific cwd
fn init_jj_repo_with_cwd(cwd: &Path) -> Result<()> {
    let output = std::process::Command::new("jj")
        .args(["git", "init"])
        .current_dir(cwd)
        .output()
        .context("Failed to run jj git init")?;

    if !output.status.success() {
        bail!(
            "jj git init failed: {}",
            String::from_utf8_lossy(&output.stderr)
        );
    }

    Ok(())
}

#[cfg(test)]
mod tests {
    use std::process::Command;

    use tempfile::TempDir;

    use super::*;

    /// Check if jj is available in PATH
    fn jj_is_available() -> bool {
        Command::new("jj")
            .arg("--version")
            .output()
            .map(|o| o.status.success())
            .unwrap_or(false)
    }

    /// Helper to setup a test JJ repository
    /// Returns None if jj is not available
    fn setup_test_jj_repo() -> Result<Option<TempDir>> {
        if !jj_is_available() {
            return Ok(None);
        }

        let temp_dir = TempDir::new().context("Failed to create temp dir")?;

        // Initialize a JJ repo in the temp directory
        let output = Command::new("jj")
            .args(["git", "init"])
            .current_dir(temp_dir.path())
            .output()
            .context("Failed to run jj git init")?;

        if !output.status.success() {
            bail!(
                "jj git init failed: {}",
                String::from_utf8_lossy(&output.stderr)
            );
        }

        Ok(Some(temp_dir))
    }

    #[test]
    fn test_init_creates_jjz_directory() -> Result<()> {
        let Some(temp_dir) = setup_test_jj_repo()? else {
            eprintln!("Skipping test: jj not available");
            return Ok(());
        };

        // Run init with the temp directory as cwd
        let result = run_with_cwd(Some(temp_dir.path()));

        // Check result
        result?;

        // Verify .jjz directory was created (use absolute path)
        let jjz_path = temp_dir.path().join(".jjz");
        assert!(jjz_path.exists(), ".jjz directory was not created");
        assert!(jjz_path.is_dir(), ".jjz is not a directory");

        Ok(())
    }

    #[test]
    fn test_init_creates_config_toml() -> Result<()> {
        let Some(temp_dir) = setup_test_jj_repo()? else {
            eprintln!("Skipping test: jj not available");
            return Ok(());
        };

        let result = run_with_cwd(Some(temp_dir.path()));
        result?;

        // Verify config.toml was created
        let config_path = temp_dir.path().join(".jjz/config.toml");
        assert!(config_path.exists(), "config.toml was not created");
        assert!(config_path.is_file(), "config.toml is not a file");

        // Verify it contains expected content
        let content = fs::read_to_string(&config_path)?;
        assert!(content.contains("workspace_dir"));
        assert!(content.contains("[watch]"));
        assert!(content.contains("[zellij]"));
        assert!(content.contains("[dashboard]"));

        Ok(())
    }

    #[test]
    fn test_init_creates_state_db() -> Result<()> {
        let Some(temp_dir) = setup_test_jj_repo()? else {
            eprintln!("Skipping test: jj not available");
            return Ok(());
        };

        let result = run_with_cwd(Some(temp_dir.path()));
        result?;

        // Verify state.db was created
        let db_path = temp_dir.path().join(".jjz/state.db");
        assert!(db_path.exists(), "state.db was not created");
        assert!(db_path.is_file(), "state.db is not a file");

        // Verify it's a valid SQLite database with correct schema
        let db = SessionDb::open(&db_path)?;
        let sessions = db.list(None)?;
        assert_eq!(sessions.len(), 0); // Should be empty initially

        Ok(())
    }

    #[test]
    fn test_init_creates_layouts_directory() -> Result<()> {
        let Some(temp_dir) = setup_test_jj_repo()? else {
            eprintln!("Skipping test: jj not available");
            return Ok(());
        };

        let result = run_with_cwd(Some(temp_dir.path()));
        result?;

        // Verify layouts directory was created
        let layouts_path = temp_dir.path().join(".jjz/layouts");
        assert!(layouts_path.exists(), "layouts directory was not created");
        assert!(layouts_path.is_dir(), "layouts is not a directory");

        Ok(())
    }

    #[test]
    fn test_init_handles_already_initialized() -> Result<()> {
        let Some(temp_dir) = setup_test_jj_repo()? else {
            eprintln!("Skipping test: jj not available");
            return Ok(());
        };

        // First init should succeed
        let result1 = run_with_cwd(Some(temp_dir.path()));
        assert!(result1.is_ok());

        // Second init should not fail, just inform user
        let result2 = run_with_cwd(Some(temp_dir.path()));
        assert!(result2.is_ok());

        Ok(())
    }

    #[test]
    fn test_init_auto_creates_jj_repo() -> Result<()> {
        // This test verifies that if we're not in a JJ repo,
        // the init command will create one automatically
        if !jj_is_available() {
            eprintln!("Skipping test: jj not available");
            return Ok(());
        }

        let temp_dir = TempDir::new()?;

        // Before JJ init, should not be a repo
        // After our init command runs, it will create a JJ repo automatically
        // So we just verify the automatic initialization works
        let result = run_with_cwd(Some(temp_dir.path()));

        // Should succeed because init_jj_repo is called automatically
        assert!(result.is_ok());

        // Verify JJ repo was created
        assert!(
            temp_dir.path().join(".jj").exists(),
            "JJ repo should be auto-created"
        );

        Ok(())
    }

    #[test]
    fn test_default_config_is_valid_toml() -> Result<()> {
        // Parse DEFAULT_CONFIG to ensure it's valid TOML
        let parsed: toml::Value =
            toml::from_str(DEFAULT_CONFIG).context("DEFAULT_CONFIG is not valid TOML")?;

        // Verify key sections exist
        assert!(parsed.get("watch").is_some());
        assert!(parsed.get("zellij").is_some());
        assert!(parsed.get("dashboard").is_some());
        assert!(parsed.get("agent").is_some());
        assert!(parsed.get("session").is_some());

        Ok(())
    }

    #[test]
    fn test_default_config_has_correct_values() -> Result<()> {
        let parsed: toml::Value = toml::from_str(DEFAULT_CONFIG)?;

        // Check some key default values from config.cue
        assert_eq!(
            parsed.get("workspace_dir").and_then(|v| v.as_str()),
            Some("../{repo}__workspaces")
        );
        assert_eq!(
            parsed.get("default_template").and_then(|v| v.as_str()),
            Some("standard")
        );

        // Check watch config
        let watch = parsed.get("watch").and_then(|v| v.as_table());
        assert!(watch.is_some());
        assert_eq!(
            watch
                .and_then(|w| w.get("enabled"))
                .and_then(toml::Value::as_bool),
            Some(true)
        );
        assert_eq!(
            watch
                .and_then(|w| w.get("debounce_ms"))
                .and_then(toml::Value::as_integer),
            Some(100)
        );

        // Check zellij config
        let zellij = parsed.get("zellij").and_then(|v| v.as_table());
        assert!(zellij.is_some());
        assert_eq!(
            zellij
                .and_then(|z| z.get("session_prefix"))
                .and_then(|v| v.as_str()),
            Some("jjz")
        );
        assert_eq!(
            zellij
                .and_then(|z| z.get("use_tabs"))
                .and_then(toml::Value::as_bool),
            Some(true)
        );

        Ok(())
    }
}
