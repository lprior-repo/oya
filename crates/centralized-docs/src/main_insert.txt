
    Ok(())
}

/// Run ingest-git command (clone + index) using git2-rs
///
/// Strategy:
/// 1. Clone git repository using git2-rs
/// 2. Find all markdown files
/// 3. Use existing index pipeline (same as ingest command)
fn run_ingest_git(
    repo_url: &str,
    output: &Path,
    branch: Option<String>,
    depth: u32,
    project_name: &Option<String>,
) -> Result<()> {
    println!("\n{}", "=".repeat(70));
    println!("DOC_TRANSFORMER v5.0 - INGEST-GIT");
    println!("{}\n", "=".repeat(70));

    println!("[GIT CLONE] Target: {repo_url}");
    println!("  Options: depth={}, branch={}",
        depth,
        branch.as_deref().unwrap_or("main")
    );
    println!();

    let temp_dir = output.join(".git-clone");
    std::fs::create_dir_all(&temp_dir)?;

    let mut fetch_options = git2::FetchOptions::new();
    if depth > 0 {
        fetch_options.depth(git2::Depth::Single { depth: depth as i32 });
    }

    println!("[GIT CLONE] Cloning repository...");
    let repo = git2::Repository::clone(repo_url, &temp_dir)
        .branch(branch.as_deref())
        .fetch_options(fetch_options)
        .map_err(|e| anyhow::anyhow!("Failed to clone repository: {e}"))?;

    println!("  âœ“ Clone successful");
    println!();

    let mut markdown_files = Vec::new();
    let mut walk_iter = walkdir::WalkDir::new(&temp_dir).into_iter();

    while let Some(entry) = walk_iter.next() {
        let entry = entry.map_err(|e| anyhow::anyhow!("Walk error: {e}"))?;

        if !entry.file_type().is_file() {
            continue;
        }

        let path = entry.path();
        if path.extension()
            .map(|ext| ext.eq_ignore_ascii_case("md"))
            .unwrap_or(false)
        {
            markdown_files.push(path.to_path_buf());
        }
    }

    println!("[DISCOVER] Found {} markdown files", markdown_files.len());
    println!();

    if markdown_files.is_empty() {
        anyhow::bail!(
            "No markdown files found in cloned repository. \
            Please verify the repository contains documentation."
        );
    }

    let name = project_name.as_ref().cloned().unwrap_or_else(|| {
        url::Url::parse(repo_url)
            .map(|u| {
                u.path_segments()
                    .and_then(|s| s.last())
                    .unwrap_or("Documentation")
                    .to_string()
            })
            .unwrap_or_else(|_| "Documentation".to_string())
    });

    let index_config = IndexConfig {
        generate_llms: true,
        project_name: name.clone(),
        project_desc: format!("Documentation cloned from {repo_url}"),
        ..Default::default()
    };

    println!("[INDEX] Running indexing pipeline...");
    run_index(&temp_dir, output, &index_config)?;

    println!();
    println!("{}", "=".repeat(70));
    println!("GIT INGEST COMPLETE");
    println!("{}", "=".repeat(70));
    println!("Source:     {}", repo_url);
    println!("Output:     {}", output.display());
    println!("Documents:  {}", markdown_files.len());
    println!("Entry:      llms.txt (AI should read this first)");
    println!("{}", "=".repeat(70));
    println!();

    Ok(())
}

/// Run search command using Tantivy (with fallback to BM25)
