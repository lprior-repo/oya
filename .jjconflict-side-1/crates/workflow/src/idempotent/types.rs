//! Type-safe wrapper for idempotency keys.
//!
//! This module provides a newtype wrapper around `Uuid` to prevent
//! accidental misuse of idempotency keys and to add domain-specific
//! functionality.

#![deny(clippy::unwrap_used)]
#![deny(clippy::expect_used)]
#![deny(clippy::panic)]
#![warn(clippy::pedantic)]

use serde::{Deserialize, Serialize};
use std::fmt;
use std::hash::Hash;
use std::str::FromStr;
use uuid::Uuid;

/// Type-safe wrapper for idempotency keys.
///
/// This newtype wrapper provides:
/// - **Type safety**: Prevents mixing idempotency keys with other UUIDs
/// - **Domain semantics**: Clear intent through type system
/// - **Serialization**: Built-in serde support for storage/transmission
///
/// # Examples
///
/// ```
/// use oya_workflow::idempotent::IdempotencyKey;
/// use uuid::Uuid;
///
/// # fn main() -> Result<(), Box<dyn std::error::Error>> {
/// // Create from a UUID (generated by idempotency_key function)
/// let uuid = Uuid::new_v4();
/// let key = IdempotencyKey::from(uuid);
///
/// // Convert to string for storage
/// let key_str = key.to_string();
///
/// // Parse back from string
/// let key2: IdempotencyKey = key_str.parse()?;
/// assert_eq!(key, key2);
/// # Ok(())
/// # }
/// ```
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub struct IdempotencyKey(Uuid);

impl IdempotencyKey {
    /// Creates a new `IdempotencyKey` from a `Uuid`.
    ///
    /// # Examples
    ///
    /// ```
    /// use oya_workflow::idempotency_key;
    /// use oya_workflow::idempotent::IdempotencyKey;
    ///
    /// # fn main() -> Result<(), Box<dyn std::error::Error>> {
    /// let key = idempotency_key("bead-123", &"input data")?;
    /// let wrapped = IdempotencyKey::new(key);
    /// # Ok(())
    /// # }
    /// ```
    #[must_use]
    pub const fn new(uuid: Uuid) -> Self {
        Self(uuid)
    }

    /// Returns the underlying `Uuid`.
    ///
    /// # Examples
    ///
    /// ```
    /// use oya_workflow::idempotency_key_from_bytes;
    /// use oya_workflow::idempotent::IdempotencyKey;
    ///
    /// let uuid = idempotency_key_from_bytes("bead-123", b"input");
    /// let key = IdempotencyKey::new(uuid);
    ///
    /// assert_eq!(key.as_uuid(), uuid);
    /// ```
    #[must_use]
    pub const fn as_uuid(self) -> Uuid {
        self.0
    }

    /// Returns a reference to the underlying `Uuid`.
    ///
    /// This is useful when you need to pass the UUID to functions that
    /// take references.
    ///
    /// # Examples
    ///
    /// ```
    /// use oya_workflow::idempotency_key_from_bytes;
    /// use oya_workflow::idempotent::IdempotencyKey;
    ///
    /// let uuid = idempotency_key_from_bytes("bead-123", b"input");
    /// let key = IdempotencyKey::new(uuid);
    ///
    /// assert_eq!(key.as_uuid_ref(), &uuid);
    /// ```
    #[must_use]
    pub const fn as_uuid_ref(&self) -> &Uuid {
        &self.0
    }

    /// Returns the string representation of the key.
    ///
    /// This is the canonical string format (e.g., "550e8400-e29b-41d4-a716-446655440000").
    ///
    /// # Examples
    ///
    /// ```
    /// use oya_workflow::idempotency_key_from_bytes;
    /// use oya_workflow::idempotent::IdempotencyKey;
    ///
    /// let uuid = idempotency_key_from_bytes("bead-123", b"input");
    /// let key = IdempotencyKey::new(uuid);
    ///
    /// let key_str = key.to_string();
    /// assert_eq!(key_str, uuid.to_string());
    /// ```
    #[must_use]
    pub fn as_str(&self) -> String {
        self.0.to_string()
    }

    /// Converts the key to its string representation.
    ///
    /// This allocates a new `String`. For zero-copy string access, use
    /// [`IdempotencyKey::as_str`] instead.
    ///
    /// # Examples
    ///
    /// ```
    /// use oya_workflow::idempotency_key_from_bytes;
    /// use oya_workflow::idempotent::IdempotencyKey;
    ///
    /// let uuid = idempotency_key_from_bytes("bead-123", b"input");
    /// let key = IdempotencyKey::new(uuid);
    ///
    /// let key_str: String = key.into_string();
    /// assert_eq!(key_str, uuid.to_string());
    /// ```
    #[must_use]
    pub fn into_string(self) -> String {
        self.0.to_string()
    }

    /// Checks if the key is nil (all zeros).
    ///
    /// # Examples
    ///
    /// ```
    /// use oya_workflow::idempotent::IdempotencyKey;
    /// use uuid::Uuid;
    ///
    /// let nil_key = IdempotencyKey::new(Uuid::nil());
    /// assert!(nil_key.is_nil());
    ///
    /// let valid_key = IdempotencyKey::new(Uuid::new_v4());
    /// assert!(!valid_key.is_nil());
    /// ```
    #[must_use]
    pub const fn is_nil(self) -> bool {
        self.0.is_nil()
    }

    /// Returns the version of the UUID.
    ///
    /// For idempotency keys generated by this crate, this will always be
    /// `Some(uuid::Version::Sha1)` (UUID v5).
    ///
    /// # Examples
    ///
    /// ```
    /// use oya_workflow::idempotency_key_from_bytes;
    /// use oya_workflow::idempotent::IdempotencyKey;
    ///
    /// let uuid = idempotency_key_from_bytes("bead-123", b"input");
    /// let key = IdempotencyKey::new(uuid);
    ///
    /// assert_eq!(key.version(), Some(uuid::Version::Sha1));
    /// ```
    #[must_use]
    pub const fn version(self) -> Option<uuid::Version> {
        self.0.get_version()
    }

    /// Returns the variant of the UUID.
    ///
    /// For idempotency keys generated by this crate, this will always be
    /// `uuid::Variant::RFC4122`.
    ///
    /// # Examples
    ///
    /// ```
    /// use oya_workflow::idempotency_key_from_bytes;
    /// use oya_workflow::idempotent::IdempotencyKey;
    ///
    /// let uuid = idempotency_key_from_bytes("bead-123", b"input");
    /// let key = IdempotencyKey::new(uuid);
    ///
    /// assert_eq!(key.variant(), uuid::Variant::RFC4122);
    /// ```
    #[must_use]
    pub const fn variant(self) -> uuid::Variant {
        self.0.get_variant()
    }
}

impl From<Uuid> for IdempotencyKey {
    fn from(uuid: Uuid) -> Self {
        Self::new(uuid)
    }
}

impl From<IdempotencyKey> for Uuid {
    fn from(key: IdempotencyKey) -> Self {
        key.0
    }
}

impl AsRef<Uuid> for IdempotencyKey {
    fn as_ref(&self) -> &Uuid {
        &self.0
    }
}

impl fmt::Display for IdempotencyKey {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        self.0.fmt(f)
    }
}

impl FromStr for IdempotencyKey {
    type Err = uuid::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        Uuid::from_str(s).map(Self::new)
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_new_from_uuid() {
        let uuid = Uuid::new_v4();
        let key = IdempotencyKey::new(uuid);

        assert_eq!(key.as_uuid(), uuid);
    }

    #[test]
    fn test_from_uuid() {
        let uuid = Uuid::new_v4();
        let key: IdempotencyKey = uuid.into();

        assert_eq!(key.as_uuid(), uuid);
    }

    #[test]
    fn test_into_uuid() {
        let uuid = Uuid::new_v4();
        let key = IdempotencyKey::new(uuid);
        let extracted_uuid: Uuid = key.into();

        assert_eq!(extracted_uuid, uuid);
    }

    #[test]
    fn test_as_uuid_ref() {
        let uuid = Uuid::new_v4();
        let key = IdempotencyKey::new(uuid);

        assert_eq!(key.as_uuid_ref(), &uuid);
    }

    #[test]
    fn test_as_ref_uuid() {
        let uuid = Uuid::new_v4();
        let key = IdempotencyKey::new(uuid);

        assert_eq!(key.as_ref(), &uuid);
    }

    #[test]
    fn test_as_str() {
        let uuid = Uuid::new_v4();
        let key = IdempotencyKey::new(uuid);

        assert_eq!(key.as_str(), uuid.to_string());
    }

    #[test]
    fn test_into_string() {
        let uuid = Uuid::new_v4();
        let key = IdempotencyKey::new(uuid);
        let key_str: String = key.into_string();

        assert_eq!(key_str, uuid.to_string());
    }

    #[test]
    fn test_display() {
        let uuid = Uuid::new_v4();
        let key = IdempotencyKey::new(uuid);

        assert_eq!(key.to_string(), uuid.to_string());
    }

    #[test]
    fn test_from_str() -> Result<(), Box<dyn std::error::Error>> {
        let uuid_str = "550e8400-e29b-41d4-a716-446655440000";
        let key: IdempotencyKey = uuid_str.parse()?;

        assert_eq!(key.to_string(), uuid_str);
        Ok(())
    }

    #[test]
    fn test_from_str_roundtrip() -> Result<(), Box<dyn std::error::Error>> {
        let uuid = Uuid::new_v4();
        let key = IdempotencyKey::new(uuid);
        let uuid_str = key.to_string();

        let parsed_key: IdempotencyKey = uuid_str.parse()?;

        assert_eq!(parsed_key, key);
        Ok(())
    }

    #[test]
    fn test_is_nil() {
        let nil_key = IdempotencyKey::new(Uuid::nil());
        assert!(nil_key.is_nil());

        let valid_key = IdempotencyKey::new(Uuid::new_v4());
        assert!(!valid_key.is_nil());
    }

    #[test]
    fn test_version() {
        let uuid_v4 = Uuid::new_v4();
        let key = IdempotencyKey::new(uuid_v4);

        assert_eq!(key.version(), Some(uuid::Version::Random));
    }

    #[test]
    fn test_variant() {
        let uuid = Uuid::new_v4();
        let key = IdempotencyKey::new(uuid);

        assert_eq!(key.variant(), uuid::Variant::RFC4122);
    }

    #[test]
    fn test_equality() {
        let uuid = Uuid::new_v4();
        let key1 = IdempotencyKey::new(uuid);
        let key2 = IdempotencyKey::new(uuid);

        assert_eq!(key1, key2);
    }

    #[test]
    fn test_inequality() {
        let key1 = IdempotencyKey::new(Uuid::new_v4());
        let key2 = IdempotencyKey::new(Uuid::new_v4());

        assert_ne!(key1, key2);
    }

    #[test]
    fn test_clone() {
        let key = IdempotencyKey::new(Uuid::new_v4());
        let cloned = key;

        assert_eq!(key, cloned);
    }

    #[test]
    fn test_copy() {
        let key = IdempotencyKey::new(Uuid::new_v4());
        let copied = key;

        // Since IdempotencyKey is Copy, key should still be usable
        assert_eq!(key, copied);
    }

    #[test]
    fn test_hash() {
        use std::collections::HashSet;

        let uuid1 = Uuid::new_v4();
        let uuid2 = Uuid::new_v4();
        let key1 = IdempotencyKey::new(uuid1);
        let key2 = IdempotencyKey::new(uuid2);

        let mut set = HashSet::new();
        set.insert(key1);
        set.insert(key2);

        assert_eq!(set.len(), 2);
    }

    #[test]
    fn test_serialization() -> Result<(), Box<dyn std::error::Error>> {
        let uuid = Uuid::new_v4();
        let key = IdempotencyKey::new(uuid);

        // Test serialization
        let serialized = serde_json::to_string(&key)?;

        // Test deserialization
        let deserialized: IdempotencyKey = serde_json::from_str(&serialized)?;

        assert_eq!(deserialized, key);
        Ok(())
    }

    #[test]
    fn test_serialization_bincode() -> Result<(), Box<dyn std::error::Error>> {
        let uuid = Uuid::new_v4();
        let key = IdempotencyKey::new(uuid);

        // Test bincode serialization
        let encoded = bincode::serde::encode_to_vec(key, bincode::config::standard())?;

        // Test bincode deserialization
        let decoded: IdempotencyKey =
            bincode::serde::decode_from_slice(&encoded, bincode::config::standard())?.0;

        assert_eq!(decoded, key);
        Ok(())
    }

    #[test]
    fn test_known_value() -> Result<(), Box<dyn std::error::Error>> {
        // Test with a known UUID value
        let uuid_str = "123e4567-e89b-12d3-a456-426614174000";
        let uuid = Uuid::from_str(uuid_str)?;
        let key = IdempotencyKey::new(uuid);

        assert_eq!(key.to_string(), uuid_str);
        assert_eq!(key.as_uuid(), uuid);
        Ok(())
    }

    #[test]
    fn test_nil_key_special_case() {
        let nil_key = IdempotencyKey::new(Uuid::nil());

        // Nil keys should be consistent
        assert!(nil_key.is_nil());
        assert_eq!(nil_key.version(), Some(uuid::Version::Nil));
        assert_eq!(nil_key.to_string(), "00000000-0000-0000-0000-000000000000");
    }

    #[test]
    fn test_multiple_nil_keys_equal() {
        let nil1 = IdempotencyKey::new(Uuid::nil());
        let nil2 = IdempotencyKey::new(Uuid::nil());

        assert_eq!(nil1, nil2);
    }

    #[test]
    fn test_invalid_uuid_string() {
        let invalid_str = "not-a-uuid";
        let result: Result<IdempotencyKey, _> = invalid_str.parse();

        assert!(result.is_err(), "Invalid UUID string should fail to parse");
    }
}
