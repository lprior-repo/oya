#!/usr/bin/env bash
#
# Generate contract for a single bead
#

set -euo pipefail

bead_id="${1:-}"
if [[ -z "$bead_id" ]]; then
    echo "Usage: $0 <bead-id>"
    exit 1
fi

# Get bead details in text format
bead_text=$(br show "$bead_id" 2>/dev/null)

if [[ -z "$bead_text" ]]; then
    echo "ERROR: Could not retrieve bead $bead_id"
    exit 1
fi

# Extract fields using grep and awk
title=$(echo "$bead_text" | grep -oP '(?<=^○ )[^\s]+.*?(?=\[)' | sed 's/·.*//' | xargs || echo "Untitled")
description=$(echo "$bead_text" | sed -n '/#/,/^$/p' | tail -n +2 | head -n -1 || echo "No description")
priority=$(echo "$bead_text" | grep -oP 'P[0-3]' || echo "P1")

echo "Generating contract for: $bead_id - $title"

contract_file="/home/lewis/src/oya/.aya/contracts/rust-contract-${bead_id}.md"
test_plan_file="/home/lewis/src/oya/.aya/test-plans/martin-fowler-tests-${bead_id}.md"

mkdir -p /home/lewis/src/oya/.aya/contracts /home/lewis/src/oya/.aya/test-plans

# Generate contract
cat > "$contract_file" <<EOF
# Rust Contract: ${title}

**Bead ID:** \`${bead_id}\`
**Priority:** ${priority}
**Generated:** $(date '+%Y-%m-%d %H:%M:%S')

## Overview

\`\`\`
${description}
\`\`\`

## Functional Requirements

### Core Functionality

Based on the bead description above, implement the following:

\`\`\`rust
// Pseudo-code representation of API surface
// TODO: Fill in with actual function signatures based on requirements

\`\`\`

### Input/Output Specifications

| Input | Type | Validation | Output |
|-------|------|------------|--------|
| TODO  | TODO | TODO       | TODO   |

## Error Handling

### Error Types

\`\`\`rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum ContractError {
    #[error("TODO: Define error cases")]
    Todo,

    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),

    #[error("Serialization error: {0}")]
    Serialization(String),
}
\`\`\`

### Error Propagation Strategy

- **Zero panics**: All error paths use \`Result<T, E>\`
- **Zero unwraps**: Forbidden in production code
- **Railway-Oriented Programming**: Use \`?\` operator throughout
- **Context preservation**: Errors include actionable context

## Performance Requirements

| Metric | Target | Measurement |
|--------|--------|-------------|
| Latency | TODO | TODO |
| Throughput | TODO | TODO |
| Memory | TODO | TODO |

## Testing Requirements

See \`$(basename "$test_plan_file")\` for comprehensive test strategy.

## Integration Points

- **Upstream dependencies**: TODO
- **Downstream consumers**: TODO
- **External systems**: TODO

## Documentation Requirements

- [ ] Public API documentation
- [ ] Example usage
- [ ] Error handling guide
- [ ] Performance characteristics

## Non-Functional Requirements

### Reliability
- TODO

### Maintainability
- TODO

### Security
- TODO

## Acceptance Criteria

1. [ ] All functional requirements implemented
2. [ ] All error cases handled
3. [ ] Zero panics, zero unwraps
4. [ ] All tests passing (see test plan)
5. [ ] Documentation complete
6. [ ] Performance targets met

---

*Generated by Architect Agent*
*Contract status: DRAFT - Pending review and refinement*
EOF

# Generate test plan
cat > "$test_plan_file" <<EOF
# Martin Fowler Test Plan: ${title}

**Bead ID:** \`${bead_id}\`
**Generated:** $(date '+%Y-%m-%d %H:%M:%S')
**Reference:** [Martin Fowler's Test Patterns](https://martinfowler.com/bliki/TestPyramid.html)

## Test Strategy Overview

This test plan follows Martin Fowler's testing philosophy with a balanced test pyramid:
- **Unit tests**: Fast, isolated, numerous
- **Integration tests**: Slower, realistic interactions
- **End-to-end tests**: Slowest, critical paths only

## Test Categories

### 1. Unit Tests (70% of tests)

#### Business Logic Tests

\`\`\`rust
#[cfg(test)]
mod unit_tests {
    use super::*;
    use rstest::*;

    #[rstest]
    #[case::valid_input("valid", "expected_output")]
    #[case::edge_case("edge", "expected_edge_output")]
    fn test_business_logic(#[case] input: &str, #[case] expected: &str) {
        // TODO: Implement test
    }
}
\`\`\`

**Coverage goal:** >90%

#### Error Path Tests

\`\`\`rust
#[rstest]
#[case::invalid_input("invalid", ContractError::InvalidInput)]
#[case::missing_required("missing", ContractError::MissingRequired)]
fn test_error_cases(#[case] input: &str, #[case] expected_error: ContractError) {
    // TODO: Test all error branches
}
\`\`\`

**Coverage goal:** 100% of error paths

#### Property-Based Tests

\`\`\`rust
#[cfg(test)]
mod proptests {
    use proptest::prelude::*;

    proptest! {
        #[test]
        fn prop_roundtrip(s in "[a-z]{1,100}") {
            // TODO: Property-based invariants
        }
    }
}
\`\`\`

### 2. Integration Tests (20% of tests)

#### Component Integration

\`\`\`rust
#[tokio::test]
async fn test_integration_with_dependency() {
    // TODO: Test real component interactions
}
\`\`\`

#### API Contract Tests

\`\`\`rust
#[tokio::test]
async fn test_api_contract() {
    // TODO: Verify API contracts
}
\`\`\`

### 3. End-to-End Tests (10% of tests)

#### Critical User Journeys

\`\`\`rust
#[tokio::test]
async fn test_critical_user_flow() {
    // TODO: Test complete user workflows
}
\`\`\`

## Test Organization

\`\`\`
crates/component-name/
├── tests/
│   ├── unit/           # Pure logic, no external deps
│   ├── integration/    # Real dependencies, isolated
│   └── e2e/           # Full system tests
└── src/
    └── lib.rs         # Includes unit tests as mod tests
\`\`\`

## Test Data Management

### Fixtures

\`\`\`rust
#[fixture]
fn valid_input() -> String {
    "valid_input".to_string()
}
\`\`\`

### Test Factories

\`\`\`rust
fn build_test_entity() -> TestEntity {
    TestEntity::builder()
        .with_field("value")
        .build()
}
\`\`\`

## Mock Strategy

- **Use real implementations** when fast and deterministic
- **Use mocks** for external services
- **Prefer fakes over mocks** for complex state

## Performance Tests

\`\`\`rust
#[cfg(test)]
mod benchmarks {
    use criterion::{black_box, criterion_group, criterion_main, Criterion};

    fn criterion_benchmark(c: &mut Criterion) {
        c.bench_function("benchmark_name", |b| {
            b.iter(|| {
                // TODO: Benchmark critical path
            });
        });
    }

    criterion_group!(benches, criterion_benchmark);
    criterion_main!(benches);
}
\`\`\`

## Chaos Testing (if applicable)

\`\`\`rust
#[tokio::test]
async fn test_fault_injection() {
    // TODO: Inject failures and verify resilience
}
\`\`\`

## Test Execution

\`\`\`bash
# Unit tests only (fast feedback)
moon run :test-unit

# Integration tests
moon run :test-integration

# Full test suite
moon run :test

# With coverage
moon run :test-coverage
\`\`\`

## Acceptance Criteria

1. [ ] All unit tests passing (>90% coverage)
2. [ ] All integration tests passing
3. [ ] Critical E2E tests passing
4. [ ] Property tests finding no counterexamples
5. [ ] Performance benchmarks meet targets
6. [ ] Zero flaky tests (100% deterministic)

## Test Metrics

| Metric | Target | Actual |
|--------|--------|--------|
| Unit test coverage | >90% | TBD |
| Integration test count | 20% of unit tests | TBD |
| E2E test count | 10% of unit tests | TBD |
| Test execution time | <30s (unit) | TBD |
| Flaky test rate | 0% | TBD |

---

*Generated by Architect Agent*
*Test plan status: DRAFT - Pending implementation*
EOF

echo "Generated artifacts:"
echo "  Contract: $contract_file"
echo "  Test plan: $test_plan_file"
echo ""
echo "To mark as ready for builders:"
echo "  br update $bead_id --status ready --labels 'stage:ready-builder,has-rust-contract,has-tests'"
