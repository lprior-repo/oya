#!/usr/bin/env bash
#
# Architect Agent v2 - Contract & Test Generation
#
# ROLE: Generates Rust contracts and Martin Fowler test plans for beads
# REPLACES: a9b95ff (processed 3 beads successfully)
#
# WORKFLOW:
# 1. Poll for open beads without contracts
# 2. Claim bead and generate contract + test plan
# 3. Mark as ready for builders
# 4. Loop continuously

set -euo pipefail

# Configuration
SLEEP_INTERVAL=30
MAX_RETRIES=3
CONTRACT_DIR="/home/lewis/src/oya/.aya/contracts"
TEST_PLAN_DIR="/home/lewis/src/oya/.aya/test-plans"
LOG_FILE="/home/lewis/src/oya/.aya/architect-agent.log"

# Ensure directories exist
mkdir -p "$CONTRACT_DIR" "$TEST_PLAN_DIR"

# Logging function
log() {
    echo "[$(date '+%Y-%m-%d %H:%M:%S')] $*" | tee -a "$LOG_FILE"
}

# Check for beads needing architect work
find_ready_beads() {
    log "Searching for beads needing architecture work..."

    # Look for open beads without "has-rust-contract" label
    local bead_id
    bead_id=$(br list --status open --json 2>/dev/null | \
        jq -r '[.[] | select(.labels == null or (.labels | index("has-rust-contract") | not))] | .[0].id // empty')

    if [[ -n "$bead_id" ]]; then
        echo "$bead_id"
        return 0
    fi

    return 1
}

# Generate Rust contract from bead description
generate_rust_contract() {
    local bead_id="$1"
    local bead_text="$2"
    local output_file="$3"

    log "Generating Rust contract for $bead_id..."

    local title
    local description
    local priority

    # Extract fields from text output
    title=$(echo "$bead_text" | grep -oP '(?<=^○ )[^\s]+.*?(?=\[)' | sed 's/·.*//' | sed 's/^ *//;s/ *$//' || echo "Untitled")
    description=$(echo "$bead_text" | sed -n '/#/,/^$/p' | tail -n +2 | head -n -1 || echo "No description")
    priority=$(echo "$bead_text" | grep -oP 'P[0-3]' || echo "P1")

    cat > "$output_file" <<EOF
# Rust Contract: ${title}

**Bead ID:** \`${bead_id}\`
**Priority:** ${priority}
**Generated:** $(date '+%Y-%m-%d %H:%M:%S')

## Overview

\`\`\`
${description}
\`\`\`

## Functional Requirements

### Core Functionality

Based on the bead description above, implement the following:

\`\`\`rust
// Pseudo-code representation of API surface
// TODO: Fill in with actual function signatures based on requirements

\`\`\`

### Input/Output Specifications

| Input | Type | Validation | Output |
|-------|------|------------|--------|
| TODO  | TODO | TODO       | TODO   |

## Error Handling

### Error Types

\`\`\`rust
use thiserror::Error;

#[derive(Error, Debug)]
pub enum ContractError {
    #[error("TODO: Define error cases")]
    Todo,

    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),

    #[error("Serialization error: {0}")]
    Serialization(String),
}
\`\`\`

### Error Propagation Strategy

- **Zero panics**: All error paths use \`Result<T, E>\`
- **Zero unwraps**: Forbidden in production code
- **Railway-Oriented Programming**: Use \`?\` operator throughout
- **Context preservation**: Errors include actionable context

## Performance Requirements

| Metric | Target | Measurement |
|--------|--------|-------------|
| Latency | TODO | TODO |
| Throughput | TODO | TODO |
| Memory | TODO | TODO |

## Testing Requirements

See \`$(basename "$TEST_PLAN_DIR")/martin-fowler-tests-${bead_id}.md\` for comprehensive test strategy.

## Integration Points

- **Upstream dependencies**: TODO
- **Downstream consumers**: TODO
- **External systems**: TODO

## Documentation Requirements

- [ ] Public API documentation
- [ ] Example usage
- [ ] Error handling guide
- [ ] Performance characteristics

## Non-Functional Requirements

### Reliability
- TODO

### Maintainability
- TODO

### Security
- TODO

## Acceptance Criteria

1. [ ] All functional requirements implemented
2. [ ] All error cases handled
3. [ ] Zero panics, zero unwraps
4. [ ] All tests passing (see test plan)
5. [ ] Documentation complete
6. [ ] Performance targets met

---

*Generated by Architect Agent (replacing a9b95ff)*
*Contract status: DRAFT - Pending review and refinement*
EOF

    log "Contract draft generated: $output_file"
}

# Generate Martin Fowler test plan
generate_test_plan() {
    local bead_id="$1"
    local bead_text="$2"
    local output_file="$3"

    log "Generating Martin Fowler test plan for $bead_id..."

    local title
    title=$(echo "$bead_text" | grep -oP '(?<=^○ )[^\s]+.*?(?=\[)' | sed 's/·.*//' | sed 's/^ *//;s/ *$//' || echo "Untitled")

    cat > "$output_file" <<EOF
# Martin Fowler Test Plan: ${title}

**Bead ID:** \`${bead_id}\`
**Generated:** $(date '+%Y-%m-%d %H:%M:%S')
**Reference:** [Martin Fowler's Test Patterns](https://martinfowler.com/bliki/TestPyramid.html)

## Test Strategy Overview

This test plan follows Martin Fowler's testing philosophy with a balanced test pyramid:
- **Unit tests**: Fast, isolated, numerous
- **Integration tests**: Slower, realistic interactions
- **End-to-end tests**: Slowest, critical paths only

## Test Categories

### 1. Unit Tests (70% of tests)

#### Business Logic Tests

\`\`\`rust
#[cfg(test)]
mod unit_tests {
    use super::*;
    use rstest::*;

    #[rstest]
    #[case::valid_input("valid", "expected_output")]
    #[case::edge_case("edge", "expected_edge_output")]
    fn test_business_logic(#[case] input: &str, #[case] expected: &str) {
        // TODO: Implement test
    }
}
\`\`\`

**Coverage goal:** >90%

#### Error Path Tests

\`\`\`rust
#[rstest]
#[case::invalid_input("invalid", ContractError::InvalidInput)]
#[case::missing_required("missing", ContractError::MissingRequired)]
fn test_error_cases(#[case] input: &str, #[case] expected_error: ContractError) {
    // TODO: Test all error branches
}
\`\`\`

**Coverage goal:** 100% of error paths

#### Property-Based Tests

\`\`\`rust
#[cfg(test)]
mod proptests {
    use proptest::prelude::*;

    proptest! {
        #[test]
        fn prop_roundtrip(s in "[a-z]{1,100}") {
            // TODO: Property-based invariants
        }
    }
}
\`\`\`

### 2. Integration Tests (20% of tests)

#### Component Integration

\`\`\`rust
#[tokio::test]
async fn test_integration_with_dependency() {
    // TODO: Test real component interactions
}
\`\`\`

#### API Contract Tests

\`\`\`rust
#[tokio::test]
async fn test_api_contract() {
    // TODO: Verify API contracts
}
\`\`\`

### 3. End-to-End Tests (10% of tests)

#### Critical User Journeys

\`\`\`rust
#[tokio::test]
async fn test_critical_user_flow() {
    // TODO: Test complete user workflows
}
\`\`\`

## Test Organization

\`\`\`
crates/component-name/
├── tests/
│   ├── unit/           # Pure logic, no external deps
│   ├── integration/    # Real dependencies, isolated
│   └── e2e/           # Full system tests
└── src/
    └── lib.rs         # Includes unit tests as mod tests
\`\`\`

## Test Data Management

### Fixtures

\`\`\`rust
#[fixture]
fn valid_input() -> String {
    "valid_input".to_string()
}
\`\`\`

### Test Factories

\`\`\`rust
fn build_test_entity() -> TestEntity {
    TestEntity::builder()
        .with_field("value")
        .build()
}
\`\`\`

## Mock Strategy

- **Use real implementations** when fast and deterministic
- **Use mocks** for external services
- **Prefer fakes over mocks** for complex state

## Performance Tests

\`\`\`rust
#[cfg(test)]
mod benchmarks {
    use criterion::{black_box, criterion_group, criterion_main, Criterion};

    fn criterion_benchmark(c: &mut Criterion) {
        c.bench_function("benchmark_name", |b| {
            b.iter(|| {
                // TODO: Benchmark critical path
            });
        });
    }

    criterion_group!(benches, criterion_benchmark);
    criterion_main!(benches);
}
\`\`\`

## Chaos Testing (if applicable)

\`\`\`rust
#[tokio::test]
async fn test_fault_injection() {
    // TODO: Inject failures and verify resilience
}
\`\`\`

## Test Execution

\`\`\`bash
# Unit tests only (fast feedback)
moon run :test-unit

# Integration tests
moon run :test-integration

# Full test suite
moon run :test

# With coverage
moon run :test-coverage
\`\`\`

## Acceptance Criteria

1. [ ] All unit tests passing (>90% coverage)
2. [ ] All integration tests passing
3. [ ] Critical E2E tests passing
4. [ ] Property tests finding no counterexamples
5. [ ] Performance benchmarks meet targets
6. [ ] Zero flaky tests (100% deterministic)

## Test Metrics

| Metric | Target | Actual |
|--------|--------|--------|
| Unit test coverage | >90% | TBD |
| Integration test count | 20% of unit tests | TBD |
| E2E test count | 10% of unit tests | TBD |
| Test execution time | <30s (unit) | TBD |
| Flaky test rate | 0% | TBD |

---

*Generated by Architect Agent*
*Test plan status: DRAFT - Pending implementation*
EOF

    log "Test plan generated: $output_file"
}

# Process a single bead
process_bead() {
    local bead_id="$1"
    local retry_count=0

    log "Processing bead: $bead_id"

    # Try to claim the bead
    while [[ $retry_count -lt $MAX_RETRIES ]]; do
        if br update "$bead_id" --status in_progress --set-labels "stage:architecting,actor:architect-replacement" 2>/dev/null; then
            break
        fi

        retry_count=$((retry_count + 1))
        log "Failed to claim $bead_id (attempt $retry_count/$MAX_RETRIES)"
        sleep 5
    done

    if [[ $retry_count -ge $MAX_RETRIES ]]; then
        log "ERROR: Could not claim bead $bead_id after $MAX_RETRIES attempts"
        return 1
    fi

    # Get bead details (text format)
    local bead_text
    bead_text=$(br show "$bead_id" 2>/dev/null)

    if [[ -z "$bead_text" ]]; then
        log "ERROR: Could not retrieve bead details for $bead_id"
        br update "$bead_id" --status open 2>/dev/null || true
        return 1
    fi

    # Generate artifacts
    local contract_file="${CONTRACT_DIR}/rust-contract-${bead_id}.md"
    local test_plan_file="${TEST_PLAN_DIR}/martin-fowler-tests-${bead_id}.md"

    generate_rust_contract "$bead_id" "$bead_text" "$contract_file"
    generate_test_plan "$bead_id" "$bead_text" "$test_plan_file"

    # Mark as ready for builders (open status with label)
    if br update "$bead_id" \
        --status open \
        --set-labels "stage:ready-builder,has-rust-contract,has-tests,contract-rev:draft" 2>/dev/null; then

        log "SUCCESS: $bead_id marked ready for builders"
        log "Contract: $contract_file"
        log "Test plan: $test_plan_file"

        # Output summary
        echo ""
        echo "=========================================="
        echo "Architect Agent: Bead Processing Complete"
        echo "=========================================="
        echo "Bead ID: $bead_id"
        echo "Title: $(echo "$bead_text" | head -1 | sed 's/^○ //;s/ \[.*//')"
        echo ""
        echo "Generated Artifacts:"
        echo "  Contract: $contract_file"
        echo "  Test Plan: $test_plan_file"
        echo ""
        echo "Next Steps:"
        echo "  1. Review and refine contract specifications"
        echo "  2. Adjust test plan based on technical constraints"
        echo "  3. Assign to builder agent for implementation"
        echo "=========================================="
        echo ""

        return 0
    else
        log "ERROR: Could not mark $bead_id as ready for builders"
        br update "$bead_id" --status open 2>/dev/null || true
        return 1
    fi
}

# Main loop
main() {
    log "Architect Agent starting..."
    log "Contract directory: $CONTRACT_DIR"
    log "Test plan directory: $TEST_PLAN_DIR"
    log "Polling interval: ${SLEEP_INTERVAL}s"
    log "Max retries per bead: $MAX_RETRIES"

    local processed_count=0
    local start_time
    start_time=$(date +%s)

    while true; do
        log "Looking for beads to process..."

        local bead_id
        if bead_id=$(find_ready_beads); then
            log "Found bead: $bead_id"

            if process_bead "$bead_id"; then
                processed_count=$((processed_count + 1))
                log "Total beads processed: $processed_count"
            else
                log "Failed to process $bead_id"
            fi

            # Brief pause after processing
            sleep 5
        else
            log "No beads ready for architecture work (waiting...)"
            sleep "$SLEEP_INTERVAL"
        fi
    done
}

# Trap signals for graceful shutdown
trap 'log "Architect Agent stopping..."; exit 0' SIGINT SIGTERM

# Run main loop
main "$@"
